/**
 * Deployment Log Stream - Real-time SSE for deployment build logs
 *
 * Streams deployment logs line-by-line as they are generated by the build worker.
 * Sends named events: "log", "status", "complete", and "heartbeat".
 * Closes the connection when the deployment reaches a terminal state.
 */

import { NextRequest } from "next/server";
import { prisma } from "@/lib/prisma";
import { requireReadAccess, isAuthError } from "@/lib/auth/api-auth";
import { getRouteLogger } from "@/lib/api/logger";
import { fail } from "@/lib/api/response";

const routeLog = getRouteLogger("deployments/[id]/logs/stream");

interface RouteParams {
  params: Promise<{ id: string }>;
}

const TERMINAL_STATUSES = ["READY", "ERROR", "CANCELLED"] as const;
const POLL_INTERVAL_MS = 1000;
const HEARTBEAT_INTERVAL_MS = 15000;

export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const authResult = await requireReadAccess(request);
    if (isAuthError(authResult)) return authResult;
    const { user } = authResult;

    const { id } = await params;

    // Verify deployment ownership
    const deployment = await prisma.deployment.findUnique({
      where: { id },
      include: {
        project: {
          select: { userId: true, name: true },
        },
      },
    });

    if (!deployment) {
      return fail("NOT_FOUND", "Deployment not found", 404);
    }

    if (deployment.project.userId !== user.id) {
      return fail("AUTH_FORBIDDEN", "Unauthorized", 403);
    }

    const encoder = new TextEncoder();

    const stream = new ReadableStream({
      async start(controller) {
        let lastLogId: string | null = null;
        let lastStatus = deployment.status;
        let isClosed = false;

        const sendEvent = (event: string, data: object) => {
          if (isClosed) return;
          try {
            controller.enqueue(
              encoder.encode(`event: ${event}\ndata: ${JSON.stringify(data)}\n\n`)
            );
          } catch {
            // Controller may already be closed
            isClosed = true;
          }
        };

        const closeStream = () => {
          if (isClosed) return;
          isClosed = true;
          clearInterval(pollInterval);
          clearInterval(heartbeatInterval);
          try {
            controller.close();
          } catch {
            // Already closed
          }
        };

        // Send initial connection confirmation
        sendEvent("connected", {
          deploymentId: id,
          projectName: deployment.project.name,
          status: deployment.status,
          branch: deployment.branch,
          startedAt: deployment.createdAt.toISOString(),
        });

        const pollLogs = async () => {
          if (isClosed) return;

          try {
            // Fetch new log entries since the last one we sent
            const logs = await prisma.deploymentLog.findMany({
              where: {
                deploymentId: id,
                ...(lastLogId && { id: { gt: lastLogId } }),
              },
              orderBy: { timestamp: "asc" },
            });

            for (const logEntry of logs) {
              sendEvent("log", {
                id: logEntry.id,
                timestamp: logEntry.timestamp.toISOString(),
                level: logEntry.level,
                message: logEntry.message,
              });
              lastLogId = logEntry.id;
            }

            // Check current deployment status
            const currentDeployment = await prisma.deployment.findUnique({
              where: { id },
              select: {
                status: true,
                url: true,
                buildTime: true,
                siteSlug: true,
                finishedAt: true,
              },
            });

            if (!currentDeployment) {
              sendEvent("error", { error: "Deployment not found" });
              closeStream();
              return;
            }

            // Emit a status event if the status has changed
            if (currentDeployment.status !== lastStatus) {
              sendEvent("status", {
                previous: lastStatus,
                current: currentDeployment.status,
              });
              lastStatus = currentDeployment.status;
            }

            // If deployment has reached a terminal state, send complete and close
            if (
              TERMINAL_STATUSES.includes(
                currentDeployment.status as (typeof TERMINAL_STATUSES)[number]
              )
            ) {
              sendEvent("complete", {
                deploymentId: id,
                status: currentDeployment.status,
                url: currentDeployment.url,
                siteSlug: currentDeployment.siteSlug,
                buildTime: currentDeployment.buildTime,
                finishedAt: currentDeployment.finishedAt?.toISOString() ?? null,
              });
              closeStream();
            }
          } catch (error) {
            routeLog.error("Log stream polling error", error);
          }
        };

        // Send initial batch of logs
        await pollLogs();

        // Continue polling only if not already closed (deployment not terminal)
        const pollInterval = setInterval(async () => {
          await pollLogs();
        }, POLL_INTERVAL_MS);

        // Send heartbeat to keep connection alive
        const heartbeatInterval = setInterval(() => {
          if (isClosed) return;
          try {
            controller.enqueue(encoder.encode(`: heartbeat\n\n`));
          } catch {
            isClosed = true;
            clearInterval(pollInterval);
            clearInterval(heartbeatInterval);
          }
        }, HEARTBEAT_INTERVAL_MS);

        // Clean up on client disconnect
        request.signal.addEventListener("abort", () => {
          closeStream();
        });
      },
    });

    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache, no-transform",
        Connection: "keep-alive",
        "X-Accel-Buffering": "no",
      },
    });
  } catch (error) {
    routeLog.error("Failed to create log stream", error);
    return fail("INTERNAL_ERROR", "Failed to create log stream", 500);
  }
}
